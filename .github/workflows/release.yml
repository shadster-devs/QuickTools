name: Build and Release QuickTools

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Import Code Signing Certificate
      uses: apple-actions/import-codesign-certs@v2
      with:
        p12-file-base64: ${{ secrets.CERTIFICATES_P12 }}
        p12-password: ${{ secrets.CERTIFICATES_P12_PASSWORD }}
        
    # No provisioning profile needed for Developer ID distribution
        
    - name: Install Sparkle Tools
      run: |
        brew install sparkle
        echo "/opt/homebrew/Caskroom/sparkle/2.7.1/bin" >> $GITHUB_PATH
        
    - name: Extract version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
        
    - name: Update version in project
      id: update_version
      run: |
        # Update CFBundleShortVersionString in Info.plist
        /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString ${{ steps.version.outputs.version }}" QuickTools/Resources/Info.plist
        
        # Generate and update build number (remove dots: 1.1.5 -> 115)
        BUILD_NUMBER=$(echo "${{ steps.version.outputs.version }}" | sed 's/\.//g')
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" QuickTools/Resources/Info.plist
        echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "Updated version: ${{ steps.version.outputs.version }}, build: $BUILD_NUMBER"
        
        # Update AppConstants.swift
        sed -i '' 's/static let appVersion = "[^"]*"/static let appVersion = "${{ steps.version.outputs.version }}"/' QuickTools/Models/AppConstants.swift
        
    - name: Build and Archive
      run: |
        xcodebuild archive \
          -project QuickTools.xcodeproj \
          -scheme QuickTools \
          -configuration Release \
          -archivePath ./build/QuickTools.xcarchive \
          CODE_SIGN_IDENTITY="Developer ID Application" \
          CODE_SIGN_STYLE=Manual \
          DEVELOPMENT_TEAM=${{ secrets.TEAM_ID }}
          
    - name: Export Archive
      run: |
        # Create export options plist
        cat > ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
          <key>method</key>
          <string>developer-id</string>
          <key>teamID</key>
          <string>${{ secrets.TEAM_ID }}</string>
          <key>signingStyle</key>
          <string>manual</string>
        </dict>
        </plist>
        EOF
        
        xcodebuild -exportArchive \
          -archivePath ./build/QuickTools.xcarchive \
          -exportPath ./build \
          -exportOptionsPlist ExportOptions.plist
          
    - name: Create ZIP for distribution
      run: |
        cd ./build
        zip -r "QuickTools-${{ steps.version.outputs.version }}.zip" QuickTools.app
        
    - name: Create App Store Connect API Key
      run: |
        # Create API key file for notarization
        echo "${{ secrets.NOTARIZE_APP_STORE_CONNECT_API_KEY }}" > AuthKey.p8
        chmod 600 AuthKey.p8
        echo "‚úÖ API key file created"
        
    - name: Notarize app with Apple
      run: |
        echo "üçé Submitting app to Apple for notarization..."
        
        # Submit for notarization
        xcrun notarytool submit "./build/QuickTools-${{ steps.version.outputs.version }}.zip" \
          --key AuthKey.p8 \
          --key-id "${{ secrets.NOTARIZE_APP_STORE_CONNECT_API_KEY_ID }}" \
          --issuer "${{ secrets.NOTARIZE_APP_STORE_CONNECT_ISSUER_ID }}" \
          --wait \
          --timeout 1h \
          --webhook-url-failure-retry-count 3
        
        echo "‚úÖ Notarization completed successfully!"
        
    - name: Staple notarization to app
      run: |
        echo "üìé Stapling notarization ticket to app..."
        
        # Extract the ZIP to staple the ticket
        cd ./build
        rm -rf QuickTools_temp
        mkdir QuickTools_temp
        cd QuickTools_temp
        unzip "../QuickTools-${{ steps.version.outputs.version }}.zip"
        
        # Staple the notarization ticket
        xcrun stapler staple "QuickTools.app"
        
        # Verify stapling worked
        echo "üîç Verifying stapled notarization..."
        xcrun stapler validate "QuickTools.app"
        spctl -a -vvv -t install "QuickTools.app"
        
        # Re-create the ZIP with notarized app
        cd ..
        rm "QuickTools-${{ steps.version.outputs.version }}.zip"
        cd QuickTools_temp
        zip -r "../QuickTools-${{ steps.version.outputs.version }}.zip" QuickTools.app
        cd ..
        rm -rf QuickTools_temp
        
        # Update the main app directory for DMG creation
        rm -rf QuickTools.app
        unzip "QuickTools-${{ steps.version.outputs.version }}.zip"
        
        echo "‚úÖ Notarized ZIP created successfully!"
        
    - name: Create DMG for distribution
      run: |
        cd ./build
        # Create a temporary directory for DMG contents
        mkdir -p dmg_temp
        cp -R QuickTools.app dmg_temp/
        # Create a symbolic link to Applications folder
        ln -s /Applications dmg_temp/Applications
        # Create the DMG
        hdiutil create -volname "QuickTools v${{ steps.version.outputs.version }}" \
          -srcfolder dmg_temp \
          -ov -format UDZO \
          "QuickTools-${{ steps.version.outputs.version }}.dmg"
        # Clean up temp directory
        rm -rf dmg_temp
        echo "‚úÖ DMG created: QuickTools-${{ steps.version.outputs.version }}.dmg"
        ls -la *.dmg
        
    - name: Import Sparkle Private Key
      run: |
        echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" > sparkle_private_key
        chmod 600 sparkle_private_key
        ls -la sparkle_private_key
        echo "Private key file created"
        
    - name: Sign update with Sparkle
      id: sign
      run: |
        echo "Checking build directory..."
        ls -la ./build/
        echo "Checking app bundle structure..."
        ls -la ./build/QuickTools.app/
        ls -la ./build/QuickTools.app/Contents/
        ls -la ./build/QuickTools.app/Contents/MacOS/
        echo "Checking private key..."
        ls -la sparkle_private_key
        echo "Checking if app is properly signed..."
        codesign -dv ./build/QuickTools.app
        echo "Signing ZIP with Sparkle..."
        SIGNATURE_RAW=$(/opt/homebrew/Caskroom/sparkle/2.7.1/bin/sign_update "./build/QuickTools-${{ steps.version.outputs.version }}.zip" --ed-key-file sparkle_private_key)
        echo "Raw signature output: '$SIGNATURE_RAW'"
        
        # Extract just the signature part (everything between = and space/length)
        if [[ $SIGNATURE_RAW == *"sparkle:edSignature="* ]]; then
          SIGNATURE=$(echo "$SIGNATURE_RAW" | sed -n 's/.*sparkle:edSignature=\([^ ]*\).*/\1/p')
        else
          SIGNATURE="$SIGNATURE_RAW"
        fi
        
        echo "Cleaned signature: '$SIGNATURE'"
        echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT
        
    - name: Get file size
      id: filesize
      run: |
        SIZE=$(stat -f%z "./build/QuickTools-${{ steps.version.outputs.version }}.zip")
        echo "size=$SIZE" >> $GITHUB_OUTPUT
        echo "File size: $SIZE bytes"
        
    - name: Generate Release Notes
      id: notes
      run: |
        # Extract release notes from git commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        if [ -n "$LAST_TAG" ]; then
          NOTES=$(git log --pretty=format:"- %s" $LAST_TAG..HEAD)
        else
          NOTES="Initial release of QuickTools"
        fi
        
        # Create formatted release notes
        cat > release_notes.md << EOF
        ## What's New in v${{ steps.version.outputs.version }}
        
        $NOTES
        
        ## Download Options
        
        ### üöÄ **Recommended: DMG Installer**
        - **QuickTools-${{ steps.version.outputs.version }}.dmg** - Professional installer with drag-to-Applications experience
        
        ### üì¶ **Alternative: ZIP Archive**  
        - **QuickTools-${{ steps.version.outputs.version }}.zip** - Direct app bundle (used by auto-updater)
        
        ## Installation
        **DMG**: Double-click and drag QuickTools to Applications folder  
        **ZIP**: Extract and move QuickTools.app to Applications folder
        
        ## Security & Trust
        ‚úÖ **Code Signed** with Apple Developer ID Certificate  
        ‚úÖ **Notarized** by Apple - No security warnings!
        
        ## Automatic Updates
        This version supports automatic updates via Sparkle. Future updates will be delivered automatically.
        EOF
        
    - name: Create GitHub Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: QuickTools v${{ steps.version.outputs.version }}
        body_path: release_notes.md
        draft: false
        prerelease: false
        
    - name: Upload ZIP Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./build/QuickTools-${{ steps.version.outputs.version }}.zip
        asset_name: QuickTools-${{ steps.version.outputs.version }}.zip
        asset_content_type: application/zip
        
    - name: Upload DMG Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./build/QuickTools-${{ steps.version.outputs.version }}.dmg
        asset_name: QuickTools-${{ steps.version.outputs.version }}.dmg
        asset_content_type: application/x-apple-diskimage
        
    - name: Update Appcast
      run: |
        # Create appcast update script
        cat > update_appcast.py << 'EOF'
        #!/usr/bin/env python3
        import xml.etree.ElementTree as ET
        import sys
        import os
        from datetime import datetime
        
        def update_appcast(version, build_number, signature, filesize, repository):
            """Update appcast.xml with new version entry"""
            
            print(f"Updating appcast for version {version} (build {build_number})")
            print(f"Signature: {signature}")
            
            # Create new entry XML with current date
            current_date = datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S +0000')
            new_entry_xml = f'''<item xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
            <title>QuickTools {version}</title>
            <description><![CDATA[
                <h3>QuickTools {version}</h3>
                <p>New release of QuickTools with essential developer tools for your menu bar.</p>
            ]]></description>
            <pubDate>{current_date}</pubDate>
            <sparkle:version>{build_number}</sparkle:version>
            <sparkle:shortVersionString>{version}</sparkle:shortVersionString>
            <sparkle:minimumSystemVersion>13.0</sparkle:minimumSystemVersion>
            <enclosure 
                url="https://github.com/{repository}/releases/download/v{version}/QuickTools-{version}.zip"
                sparkle:edSignature="{signature}"
                length="{filesize}"
                type="application/octet-stream" />
        </item>'''
            
            try:
                # Parse the new entry first to validate it
                new_item = ET.fromstring(new_entry_xml)
                print("‚úÖ New entry XML is valid")
                
                # Read existing appcast
                if os.path.exists('appcast.xml'):
                    tree = ET.parse('appcast.xml')
                    root = tree.getroot()
                    print("‚úÖ Existing appcast parsed successfully")
                else:
                    # Create new appcast if it doesn't exist
                    root = ET.Element('rss', version="2.0")
                    root.set('xmlns:sparkle', 'http://www.andymatuschak.org/xml-namespaces/sparkle')
                    root.set('xmlns:dc', 'http://purl.org/dc/elements/1.1/')
                    channel = ET.SubElement(root, 'channel')
                    ET.SubElement(channel, 'title').text = 'QuickTools Updates'
                    ET.SubElement(channel, 'description').text = 'Updates for QuickTools - Essential developer tools in your menu bar'
                    ET.SubElement(channel, 'language').text = 'en'
                    ET.SubElement(channel, 'link').text = f'https://github.com/{repository}'
                    tree = ET.ElementTree(root)
                    print("‚úÖ New appcast created")
                
                # Find channel
                channel = root.find('channel')
                if channel is None:
                    print("‚ùå No channel found in appcast")
                    return False
                
                # Add new item as first item
                items = channel.findall('item')
                if items:
                    # Insert before first existing item
                    channel.insert(list(channel).index(items[0]), new_item)
                else:
                    # Add as first item after other channel elements
                    title_elem = channel.find('title')
                    if title_elem is not None:
                        insert_index = list(channel).index(title_elem) + 1
                        # Skip description, language, link elements
                        for elem in list(channel)[insert_index:]:
                            if elem.tag in ['description', 'language', 'link']:
                                insert_index += 1
                            else:
                                break
                        channel.insert(insert_index, new_item)
                    else:
                        channel.append(new_item)
                
                print("‚úÖ New item added to appcast")
                
                # Write updated appcast
                tree.write('appcast.xml', encoding='utf-8', xml_declaration=True)
                print("‚úÖ Updated appcast.xml written successfully")
                
                return True
                
            except Exception as e:
                print(f"‚ùå Error updating appcast: {e}")
                import traceback
                traceback.print_exc()
                return False
        
        if __name__ == "__main__":
            if len(sys.argv) != 6:
                print("Usage: python3 update_appcast.py <version> <build_number> <signature> <filesize> <repository>")
                sys.exit(1)
            
            version = sys.argv[1]
            build_number = sys.argv[2]
            signature = sys.argv[3]
            filesize = sys.argv[4]
            repository = sys.argv[5]
            
            success = update_appcast(version, build_number, signature, filesize, repository)
            if not success:
                sys.exit(1)
            
            print(f"üéâ Successfully updated appcast for version {version} (build {build_number})")
        EOF
        
        # Run the appcast update script
        python3 update_appcast.py "${{ steps.version.outputs.version }}" "${{ steps.update_version.outputs.build_number }}" "${{ steps.sign.outputs.signature }}" "${{ steps.filesize.outputs.size }}" "${{ github.repository }}"
        
    - name: Commit and push updated appcast
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add appcast.xml
        if git diff --staged --quiet; then
          echo "No changes to appcast.xml"
        else
          git commit -m "Update appcast for v${{ steps.version.outputs.version }}"
          git push origin HEAD:main
        fi
        
    - name: Clean up
      run: |
        rm -f sparkle_private_key
        rm -f AuthKey.p8
        rm -f new_entry.xml
        rm -f release_notes.md 